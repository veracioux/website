# NOTE: You can run 'dgen' to generate the production Dockerfile and the
# Dockerfile used by docker-compose

FROM alpine:3.15.0

## Install global dependencies
RUN apk add --no-cache python3 py3-pip nodejs curl
# Install pnpm
RUN curl -L https://unpkg.com/@pnpm/self-installer '|' node
RUN apk add --no-cache nginx
## Dependencies for psycopg2
RUN apk add --no-cache libpq-dev
## Dependencies for pillow
RUN apk add --no-cache --virtual build-deps \
            python3-dev gcc musl-dev zlib-dev jpeg-dev
RUN apk add --no-cache zlib jpeg linux-headers
## Install pipenv
RUN pip install --no-cache-dir pipenv

## Required by 'heroku ps:exec' and wait-for-it.sh
RUN apk add --no-cache bash
RUN ln -sf /bin/bash /bin/sh

WORKDIR /app/frontend

## Install npm dependencies
COPY frontend/package.json frontend/pnpm-lock.yaml ./
RUN pnpm install --only=prod

if [ "$ENVIRONMENT" != "dev" ]; then
    ## Bundle frontend
    COPY frontend .
    RUN pnpm run build
fi

WORKDIR /app
COPY Pipfile.lock ./

## Set up virtual env
RUN LANG=en_US.UTF-8 pipenv sync
## Install the virtual env globally, so it persists in the heroku filesystem
RUN pipenv run pip freeze '|' tail -n +2 '>' /requirements.txt
RUN pip install --no-cache-dir -r /requirements.txt

## Remove build dependencies
RUN apk del build-deps

COPY . .

if [ "$ENVIRONMENT" = "production" ]; then
    COPY nginx.conf /etc/nginx/nginx.conf
    ## Port to serve nginx
    ENV PORT 8001
    CMD ./production.sh
elif [ "$ENVIRONMENT" = "dev" ]; then
    CMD ./dev.sh
else
    : # TODO
fi

# vim: filetype=dockerfile
